<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="bootstrap.min.css">
    <script src="jquery.js"></script>
    <script src="bootstrap.js"></script>
    <script src="handlebars.js"></script>
    <script src="nextprot2.js"></script>
    <script src="sequence-viewer.js"></script>
    <script src="d3.v3.js"></script>
    <!--<script src="script.js"></script>-->
    <script src="gist_templates.js"></script>
    <script src="nextprot-templates.js"></script>
    <script src="feature-viewer.js"></script>
    <script src="tripleViewer.js"></script>
</head>

<body>
<div class="row" style="margin: 0px 20px;">
    <div id="nx-overview" class="col-md-12" style="background:#fff;margin-top:10px;margin-bottom:10px;border-top:4px solid #E7EAEC;border-bottom: 1px solid #e7eaec;"></div>
</div>
<div class="row" style="margin: 0px 20px;">
    <div id="nx-isoformChoice" class="col-md-12" style="margin-bottom: -5px;"></div>
</div>
<div class="row" style="margin: 0px 20px;">
    <div id="visuContainer" class="col-md-12" style="background:#fff;padding:0px;border-top:4px solid #E7EAEC;border-bottom: 1px solid #e7eaec;">
        <div id="isoformDisplayed"></div>
        <div class="chart"></div>
    </div>
</div>
<div class="row" style="margin: 10px 20px;">
    <div id="featuresTable" class="col-md-6" style="background:#fff;padding:5px 15px;height:600px;border-top:4px solid #E7EAEC;border-bottom: 1px solid #e7eaec;"></div>
    <div class="col-md-6" style="padding-right:0px;">
        <div id="seqViewer" style="background:#fff;padding:5px 15px;;height:600px;border-top:4px solid #E7EAEC;border-bottom: 1px solid #e7eaec;"></div>
    </div>
</body>
<script>

    ($(function () {

        var Nextprot = window.Nextprot;
        var nx = new Nextprot.Client("test new nextprot feature viewer", "MatSchaeff-SIB");
        var entry = nx.getEntryName();
        //var isoName = entry + "-1";
        //var ft;
        //var seqView;
        //var currentSeq;
        //var isoforms;
        //var isoformMapping;
        //var featuresForViewer= [];
        //var featuresByIsoform = [];
        //var iFrameWidth=0;
        //var filterOptions = {
        //    processing: true,
        //    region: true,
        //    site: true,
        //    residue: true,
        //    variant:true,
        //    none:true
        //};
        //
        //function nxIsoformChoice(isoforms) {
        //    if ($("#nx-isoformChoice").length > 0) {
        //        var datas = {
        //            "isoforms": (function () {
        //                var listIsoforms = {
        //                    "visible": [],
        //                    "more": []
        //                };
        //                isoforms.sort(function (a, b) {
        //                    return parseInt(a.uniqueName.split("-")[1]) - parseInt(b.uniqueName.split("-")[1])
        //                }).forEach(function (o, index) {
        //                    if (index <= 3) listIsoforms.visible.push(o);
        //                    else listIsoforms.more.push(o);
        //                });
        //                return listIsoforms;
        //            }())
        //        };
        //        var template = HBtemplates['isoformChoice.tmpl'];
        //        var results = template(datas);
        //        $("#nx-isoformChoice").append(results);
        //        /////////// EventListener to change isoform
        //        getInfoForIsoform.isoform();
        //
        //        $("#nx-isoformChoice li:first-child").addClass("active");
        //    }
        //}
        ////function adjustHeight(div1,div2) {
        ////
        ////    $(div1).height($(div2).height());
        ////}
        //function toggleIsoformMap() {
        //    $(function () {
        //        $("#isoformMap").click(function () {
        //            $("#isoformDisplayed #isoContainer").toggle("slow");
        //        });
        //
        //        $("#isoformDisplayed #isoContainer").hide();
        //    });
        //}
        //var getInfoForIsoform = {
        //    isoform: function () {
        //        $(".isoformNames").click(function () {
        //            isoName = $(this).text();
        //            getInfoForIsoform.reload(isoName);
        //        });
        //        $("#moreIsoforms a").click(function () {
        //            var parentThis = $(this).text();
        //            console.log(parentThis);
        //            $("#extendIsoformChoice").text(parentThis);
        //        });
        //    },
        //    init: function (oneData,featuresName,metaData) {
        //        isoforms=oneData[0];
        //        nxIsoformChoice(oneData[0]);
        //
        //        iFrameWidth =$("#visuContainer").width();
        //
        //        for (var i=1; i<oneData.length-1;i++) {
        //            var feat = NXUtils.convertMappingsToIsoformMap(oneData[i],featuresName[i]);
        //            featuresByIsoform.push(feat);
        //            var featForViewer = NXViewerUtils.convertNXAnnotations(feat,metaData[i-1]);
        //            featuresForViewer.push(featForViewer);
        //        }
        //        isoformMapping = testAlgoObject(oneData[oneData.length-1]);
        //        console.log(isoformMapping);
        //        displayIsoform(isoformMapping,"#isoformDisplayed",isoName);
        //        toggleIsoformMap();
        //
        //
        //        addFiltering();
        //        createSVG(isoforms,isoName);
        //        addFeatures(isoName);
        //        fillTable(isoName);
        //        featureSelection();
        //        inverseSelection();
        //        toggleFiltering();
        //    },
        //    reload: function (isoID) {
        //        console.log(isoID);
        //        $(".chart svg").remove();
        //        createSVG(isoforms,isoID);
        //        addFeatures(isoID);
        //        fillTable(isoID);
        //        applyFiltering();
        //        featureSelection();
        //        inverseSelection();
        //        displayIsoform(isoformMapping,"#isoformDisplayed",isoID);
        //        //toggleIsoformMap();
        //    },
        //    reloadSVG: function(isoID) {
        //        $(".chart svg").remove();
        //        createSVG(isoforms,isoID);
        //        addFeatures(isoID);
        //        featureSelection();
        //        inverseSelection();
        //    }
        //};
        //
        //function displayIsoform(array,divIsoform,isoIdentifier) {
        //    $(divIsoform + " #isoContainer").html("");
        //    if (!$('#isoContainer').length > 0 ) {
        //        $(divIsoform).append("<div id=\"isoContainer\"></div>");
        //    }
        //
        //    //ft2 = new FeatureViewer(33000, "#isoformDisplayed", {
        //    //    showAxis: true,
        //    //    showSequence: false,
        //    //    brushActive: false,
        //    //    verticalLine: false
        //    //});
        //
        //    function getMax(array) {
        //        var max = 0;
        //        for (name in array) {
        //            for (var pos in array[name].positions) {
        //                if (array[name].positions[pos].second > max) max = array[name].positions[pos].second;
        //            }
        //        }
        //        return max;
        //    }
        //    function getMin(array) {
        //        var min = 100000000;
        //        for (name in array) {
        //            for (var pos in array[name].positions) {
        //                if (array[name].positions[pos].first < min) min = array[name].positions[pos].first;
        //            }
        //        }
        //        return min;
        //    }
        //    var max = getMax(array);
        //    var min = getMin(array);
        //    //var max = Math.max($.merge(array.map(function (o) {
        //    //    return o.positions.map(function (p) {
        //    //        return p.second;
        //    //    })
        //    //})));
        //    console.log(max);
        //    console.log("ISOFORM SUPPOSED TO BE DISPLAY FFS");
        //    //console.log($(divIsoform).width());
        //    var position = 20;
        //
        //    //$(divIsoform).width()
        //    var margin = {top: 10, right: 50, bottom: 0, left: 50},
        //        width =  iFrameWidth - margin.left - margin.right - 17,
        //        height = 200 - margin.top - margin.bottom;
        //    var coverageLength = 33000;
        //    var scaling = d3.scale.linear()
        //        .domain([min, max])
        //        .range([0, width]);
        //
        //    var line = d3.svg.line()
        //        .interpolate("linear")
        //        .x(function (d) {
        //            return scaling(d.x);
        //        })
        //        .y(function (d) {
        //            return d.y + 6;
        //        });
        //
        //    var svgIso = d3.select(divIsoform+" #isoContainer").append("svg")
        //        .attr("width", width + margin.left + margin.right)
        //        .attr("height", height + margin.top + margin.bottom)
        //        .style("z-index","2");
        //    var svgIsoform = svgIso
        //        .append("g")
        //        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        //
        //    var selectIsoform = function(iso) {
        //
        //    };
        //
        //    function fillSVGIsoform(data) {
        //        //rectangle: function (object, sequence, position) {
        //        console.log("YOU ARE IN THE MATRIX");
        //            var rectHeight = 12;
        //            var rectShift = 20;
        //            var rectsPro = svgIsoform.append("g")
        //                .attr("class", "rectangle")
        //                .attr("transform", "translate(0," + position + ")");
        //
        //            rectsPro.append("path")
        //                .attr("d", line([{x: min, y: 0}, {x: max, y: 0}]))
        //                .attr("class", function () {
        //                    return "line"
        //                })
        //                .style("z-index", "0")
        //                .style("stroke", "#C2DEC8")
        //                .style("stroke-width", "1px");
        //
        //            var rectsProGroup = rectsPro.selectAll("." + data.isoformAc + "Group")
        //                .data(data.positions)
        //                .enter()
        //                .append("g")
        //                .attr("class",  data.isoformAc +"Group")
        //                .attr("transform", function(d) { return "translate(" + scaling(d.first) + ",0)"});
        //
        //            rectsProGroup
        //                .append("rect")
        //                .attr("class", function () {
        //                    if (data.isoformAc === isoIdentifier) return "element "+ data.isoformAc +"Rect isoSelected";
        //                    else return "element "+ data.isoformAc +"Rect";
        //                })
        //                //.attr("y", function (d) {
        //                //    return position
        //                //})
        //                .attr("width", function (d) {
        //                    return (scaling(d.second) - scaling(d.first))})
        //                .attr("height", 12)
        //                .style("fill", "#C2DEC8")
        //                .style("z-index", "13")
        //                .style("cursor", "pointer")
        //                .on("click", function () {
        //                    getInfoForIsoform.reload(data.isoformAc);
        //                    var isoSelection = $('#nx-isoformChoice a[href=#' + data.isoformAc +']').tab('show');
        //                    if (isoSelection.parent().parent().is("#moreIsoforms")) $("#extendIsoformChoice").text(data.isoformAc);
        //
        //                });
        //
        //            rectsProGroup
        //                .append("text")
        //                .attr("class", "element "+ data.isoformAc +"Text")
        //                .attr("y", 6)
        //                .attr("dy", "0.35em")
        //                .style("font-size", "10px")
        //                .text(function(d) { return data.isoformName})
        //                .style("fill", "black")
        //                .style("z-index", "15")
        //                .style("visibility", function(d) {
        //                    if (data.isoformName) {
        //                        return (scaling(d.second) - scaling(d.first)) > data.isoformName.length * 8 ? "visible" : "hidden";
        //                    }
        //                    else return "hidden";
        //                });
        //        position += 20;
        //    }
        //    for (var name in array) {
        //        console.log(name);
        //        fillSVGIsoform(array[name],name);
        //    }
        //    svgIso.attr("height", position+10 +"px");
        //    console.log("ISOFORM SUPPOSED TO BE DISPLAY FFS");
        //
        //
        //
        //    //var yAxisScale = d3.scale.ordinal()
        //    //    .domain([0, array.length])
        //    //    .rangeRoundBands([0, 500], .1);
        //    //var yAxis = d3.svg.axis()
        //    //    .scale(yAxisScale)
        //    //    .tickValues(array.map(function (o) {return o.isoformName})) //specify an array here for values
        //    //    .tickFormat(function (d) {
        //    //        return d
        //    //    })
        //    //    .orient("left");
        //    //function addYAxis() {
        //    //    yAxisSVG = svg.append("g")
        //    //        .attr("class", "pro axis")
        //    //        .attr("transform", "translate(0," + margin.top + ")");
        //    //    updateYaxis();
        //    //}
        //    //function updateYaxis() {
        //    //
        //    //    yAxisSVGgroup = yAxisSVG
        //    //        .selectAll(".yaxis")
        //    //        .data(array.map(function (o) {return o.isoformName}))
        //    //        .enter()
        //    //        .append("g");
        //    //    yAxisSVGgroup
        //    //        .append("polygon")       // attach a polygon
        //    //        .style("stroke", "none")  // colour the line
        //    //        .style("fill", "rgba(95,46,38,0.2)")     // remove any fill colour
        //    //        .attr("points", function(d) {
        //    //            return (margin.left-15)+"," + (d.y -3) + ", "+ (margin.left-15)+"," + (d.y +12) + ", "+ (margin.left-7)+"," + (d.y +4.5);  // x,y points
        //    //        });
        //    //    yAxisSVGgroup
        //    //        .append("rect")
        //    //        .style("fill","rgba(95,46,38,0.2)")
        //    //        .attr("x", function () {
        //    //            return margin.left - 95
        //    //        })
        //    //        .attr("y", function (d) {
        //    //            return d.y - 3
        //    //        })
        //    //        .attr("width", "80")
        //    //        .attr("height", "15");
        //    //    yAxisSVGgroup
        //    //        .append("text")
        //    //        .attr("class", "yaxis")
        //    //        .attr("text-anchor", "end")
        //    //        .attr("x", function () {
        //    //            return margin.left - 20
        //    //        })
        //    //        .attr("y", function (d) {
        //    //            return d.y + 8
        //    //        })
        //    //        .text(function (d) {
        //    //            return d.title
        //    //        });
        //    //}
        //}
        //
        //function createSVG(sequences,isoName) {
        //    sequences.forEach(function (o) {
        //        if (o.uniqueName === isoName) {
        //            currentSeq = o.sequence;
        //            ft = new FeatureViewer(currentSeq, ".chart", {
        //                showAxis: true,
        //                showSequence: true,
        //                brushActive: true,
        //                verticalLine: false
        //            });
        //            seqView = new Sequence(currentSeq,isoName);
        //            seqView.render('#seqViewer', {
        //                'showLineNumbers': true,
        //                'wrapAminoAcids': true,
        //                'charsPerLine': 50,
        //                'search':true,
        //                'toolbar':true
        //            });
        //
        //
        //        }
        //    });
        //}
        //
        //function addFeatures(isoName) {
        //    console.log("REGENESIS OF THE DATAAAAA");
        //    console.log(featuresForViewer[3]);
        //    for (var i=0;i<featuresForViewer.length;i++) {
        //        if (Object.keys(featuresForViewer[i]).length !== 0 && featuresForViewer[i].hasOwnProperty(isoName) && filterOptions[featuresForViewer[i][isoName].filter] === true) {
        //            var feature = jQuery.extend({}, featuresForViewer[i][isoName]);
        //            ft.addFeature(feature);
        //        }
        //    }
        //}
        //function addFiltering() {
        //    $(".chart").append("<div id=\"svgHeader\" class=\"row\" style=\"margin:0px 20px\"></div>");
        //    var filterHash = {
        //        processing: "Processing",
        //        residue: "Modified residue",
        //        region: "Region",
        //        site: "Site",
        //        variant: "Variant"
        //    };
        //    var activeFiltering = {
        //        filters: {}
        //    };
        //    for (var i=0;i<featuresForViewer.length;i++) {
        //        if (Object.keys(featuresForViewer[i]).length !== 0) {
        //            var filter = featuresForViewer[i][Object.keys(featuresForViewer[i])[0]].filter;
        //            if (filter !== "none" && (!activeFiltering.filters[filter])) {
        //                activeFiltering.filters[filter]=filterHash[filter];
        //            }
        //        }
        //    }
        //    console.log(activeFiltering);
        //    var template = HBtemplates['filter.tmpl'];
        //    var results = template(activeFiltering);
        //    $("#svgHeader").html(results);
        //
        //
        //}
        //function fillTable(isoName) {
        //
        //    if ($("#featuresTable").length > 0) {
        //        var number = 0;
        //        var features = [];
        //        featuresByIsoform.forEach( function (d) { if (d.hasOwnProperty(isoName)) features.push(d[isoName])});
        //        for (feat in featuresByIsoform) if(featuresByIsoform[feat].hasOwnProperty(isoName)) number += featuresByIsoform[feat][isoName].length;
        //    Handlebars.registerHelper('position', function (length, options) {
        //        console.log(this);
        //            if (length === 1) return this.start;
        //            else if (this.category = "Disulfide bond") return this.start + "<span style=\"line-height: 0.8; vertical-align:top\">&#x256d;&#x256e;</span>" + this.end;
        //            else return this.start + " - " + this.end;
        //    });
        //
        //    Handlebars.registerHelper('className', function (category, options) {
        //        return category.replace(' ','');
        //    });
        //    var datas = {
        //            features: features,
        //            featuresLength: number
        //        };
        //
        //        var template = HBtemplates['featureTable2.tmpl'];
        //        var results = template(datas);
        //        $("#featuresTable").html(results);
        //    }
        //}
        //function testAlgo() {
        //    //Algorithm to concat exons of each isoform
        //    //Tetris-like
        //
        //    var isoforms = [
        //        [[2,3],[4,6],[8,10],[13,14]],
        //        [[2,3],[5,7],[8,10],[11,12],[13,14]],
        //        [[0,1],[2,3],[5,6],[8,9],[13,14]]
        //    ];
        //    var positions=[];
        //    var decalage=[];
        //    // GET All positions x & y into new array positions
        //    for (var iso in isoforms) {
        //        isoforms[iso].forEach(function (o) {
        //            positions.push(o[0],o[1]);
        //        })
        //    }
        //    // delete double in list of positions
        //    positions = positions.filter(function(elem, index, self) {
        //        return index == self.indexOf(elem);});
        //    // sort positions
        //    positions.sort(function(a,b) {return a-b});
        //
        //    //for each interval between position, check if there is something in isoforms
        //    //if not, add the empty interval to array decalage
        //    for (var i=0;i<positions.length-1;i++) {
        //        var presence = false;
        //        for (var j in isoforms) {
        //            for (var k in isoforms[j]) {
        //                if (isoforms[j][k][0] > positions[i+1]) break;
        //                else if (isoforms[j][k][0]<= positions[i] && isoforms[j][k][1] >= positions[i+1]) {
        //                    presence=true;
        //                    break;
        //                }
        //            }
        //            if (presence === true) break;
        //        }
        //        if (presence === false) decalage.push({x:positions[i],length:positions[i+1]-positions[i]});
        //    }
        //    //For each "hole", apply a shift by adding the length of the hole to the value after the hole
        //    //In the same time, if i[y] == i+1[x] merge those two
        //    for (var i=decalage.length-1;i>=0;i--) {
        //        for (var j in isoforms) {
        //            for (var k=isoforms[j].length-1;k>=0;k--) {
        //                if (isoforms[j][k][0] < decalage[i].x) break;
        //                else {
        //                    isoforms[j][k][0] -= decalage[i].length;
        //                    isoforms[j][k][1] -= decalage[i].length;
        //                }
        //                if (k !=isoforms[j].length-1 && isoforms[j][k+1][0] === isoforms[j][k][1]) {
        //                    isoforms[j][k][1] = isoforms[j][k+1][1];
        //                    isoforms[j].splice(k+1,1);
        //                }
        //            }
        //        }
        //    }
        //    console.log(positions);
        //    console.log(decalage);
        //    console.log(isoforms);
        //}
        //function testAlgoObject(isoformsMapping) {
        //    //Algorithm to concat exons of each isoform
        //    //Tetris-like
        //    //var isoformsMapping = [];
        //    ////for (var name in isoformsMap) {
        //    ////    console.log(name);
        //    ////    isoformsMapping.push(isoformsMap[name]);
        //    ////}
        //    //
        //    //var isoNamesSorted = Object.keys(isoformsMap).sort();
        //    //
        //    //console.log(isoNamesSorted);
        //    //for (var name in isoNamesSorted) {
        //    //    console.log(isoNamesSorted[name]);
        //    //    isoformsMapping.push(isoformsMap[isoNamesSorted[name]]);
        //    //}
        //    //var meta = jQuery.extend([], isoformsMapping);
        //    //isoformsMapping.sort(function (a,b) {
        //    //    var textA = a.isoformName;
        //    //    var textB = b.isoformName;
        //    //    return (textA < textB) ? -1 : (textA > textB) ? 1 : 0;
        //    //});
        //    //
        //    //console.log("metaaa");
        //    //console.log(meta);
        //    var positions=[];
        //    var decalage=[];
        //    // GET All positions x & y into new array positions
        //    for (var iso in isoformsMapping) {
        //        isoformsMapping[iso].positions.forEach(function (o) {
        //            positions.push(o.first, o.second);
        //        })
        //    }
        //    //delete double in list of positions
        //    positions = positions.filter(function(elem, index, self) {
        //        return index == self.indexOf(elem);});
        //    // sort positions
        //    positions.sort(function(a,b) {return a-b});
        //
        //    console.log(positions);
        //    //for each interval between position, check if there is something in isoforms
        //    //if not, add the empty interval to array decalage
        //    for (var i=0;i<positions.length-1;i++) {
        //        var presence = false;
        //        for (var j in isoforms) {
        //            for (var k in isoformsMapping[j].positions) {
        //                if (isoformsMapping[j].positions[k].first > positions[i+1]) break;
        //                else if (isoformsMapping[j].positions[k].first<= positions[i] && isoformsMapping[j].positions[k].second >= positions[i+1]) {
        //                    presence=true;
        //                    break;
        //                }
        //            }
        //            if (presence === true) break;
        //        }
        //        if (presence === false) decalage.push({x:positions[i],length:positions[i+1]-positions[i]});
        //    }
        //    console.log(decalage);
        //    ////For each "hole", apply a shift by adding the length of the hole to the values after the hole
        //    ////In the same time, if i[y] == i+1[x] merge those two
        //    for (var i=decalage.length-1;i>=0;i--) {
        //        for (var j in isoformsMapping) {
        //            for (var k=isoformsMapping[j].positions.length-1;k>=0;k--) {
        //                if (isoformsMapping[j].positions[k].first < decalage[i].x) {
        //                    if (i===0 && isoformsMapping[j].positions[k+1].first === isoformsMapping[j].positions[k].second) {
        //                        isoformsMapping[j].positions[k].second = isoformsMapping[j].positions[k+1].second;
        //                        isoformsMapping[j].positions.splice(k+1,1);
        //                    }
        //                    break;
        //                }
        //                else {
        //                    isoformsMapping[j].positions[k].first -= decalage[i].length;
        //                    isoformsMapping[j].positions[k].second -= decalage[i].length;
        //                }
        //                if (k !=isoformsMapping[j].positions.length-1 && isoformsMapping[j].positions[k+1].first === isoformsMapping[j].positions[k].second) {
        //                    isoformsMapping[j].positions[k].second = isoformsMapping[j].positions[k+1].second;
        //                    isoformsMapping[j].positions.splice(k+1,1);
        //                }
        //            }
        //        }
        //    }
        //    //console.log(positions);
        //    //console.log(decalage);
        //    console.log(isoformsMapping);
        //    return isoformsMapping;
        //}
        //
        //function featureSelection() {
        //    $(".featPosition").click(function() {
        //        $(".tableHighlight").removeClass("tableHighlight");
        //        $(this).parent().parent().addClass("tableHighlight");
        //        var position = $(this).text().split(" - ").map(Number);
        //        if (position.length === 1) position.push(position[0]);
        //        var svgId = "#" + "f" + $(this).parent().parent().attr("id");
        //
        //        console.log(svgId);
        //        position[0]-=1;
        //        seqView.selection(position[0],position[1],"#C50063");
        //        ft.selection(svgId);
        //
        //        var ElementTop = $("#stringSelected").position().top-200;
        //        var scrollPosition = $("#scroller").scrollTop();
        //        var scrollingLength = ElementTop + scrollPosition;
        //        $("#scroller").animate({scrollTop: scrollingLength}, 1000);
        //
        //    })
        //}
        //function inverseSelection() {
        //    $(".element").click(function (d) {
        //        var featSelected = this.id.slice(1);
        //        var featPos = featSelected.split("_").slice(1).map(Number);
        //        featPos[0]-=1;
        //        seqView.selection(featPos[0],featPos[1],"#C50063");
        //        $(".tableHighlight").removeClass("tableHighlight");
        //        $("#"+featSelected).addClass("tableHighlight");
        //        var ElementTop = $("#"+featSelected).position().top-70;
        //        var scrollPosition = $("#featTableScroller").scrollTop();
        //        var scrollingLength = ElementTop + scrollPosition;
        //        $("#featTableScroller").animate({scrollTop: scrollingLength}, 1000);
        //        var ElementTop2 = $("#stringSelected").position().top-200;
        //        var scrollPosition2 = $("#scroller").scrollTop();
        //        var scrollingLength2 = ElementTop2 + scrollPosition2;
        //        $("#scroller").animate({scrollTop: scrollingLength2}, 1000);
        //    })
        //}
        //function toggleFiltering() {
        //    $("#filtering input:checkbox").on("change", function() {
        //        if ($(this)[0] === $("#allFilters")[0]) {
        //            var checked = $(this).prop("checked");
        //
        //            $(this).parents("#filtering")
        //                .first()
        //                .find("input[type=checkbox]")
        //                .prop("checked", checked);
        //            if (checked === false) {
        //                for(var key in filterOptions) {
        //                    filterOptions[key] = false;
        //                }
        //            }
        //            else {
        //                for(var key in filterOptions) {
        //                    filterOptions[key] = true;
        //                }
        //            }
        //            filterOptions["none"] = true;
        //        }
        //        applyFiltering();
        //        getInfoForIsoform.reloadSVG(isoName);
        //
        //    });
        //}
        //function applyFiltering() {
        //
        //    if ($("#processing").prop("checked")) {
        //        $(".Propeptide").show();
        //        $(".Matureprotein").show();
        //        $(".Initiatormeth").show();
        //        filterOptions.processing = true;
        //    }
        //    else {
        //        $(".Propeptide").hide();
        //        $(".Matureprotein").hide();
        //        $(".Initiatormeth").hide();
        //        filterOptions.processing = false;
        //    }
        //    if ($("#site").prop("checked")) {
        //        $(".Activesite").show();
        //        $(".Site").show();
        //        $(".Metalbinding").show();
        //        filterOptions.site = true;
        //    }
        //    else {
        //        $(".Activesite").hide();
        //        $(".Site").hide();
        //        $(".Metalbinding").hide();
        //        filterOptions.site = false;
        //    }
        //    if ($("#residue").prop("checked")) {
        //        $(".Modifiedresidue").show();
        //        $(".Disulfidebond").show();
        //        $(".Cross-link").show();
        //        $(".Glycosylation").show();
        //        filterOptions.residue = true;
        //    }
        //    else {
        //        $(".Modifiedresidue").hide();
        //        $(".Disulfidebond").hide();
        //        $(".Cross-link").hide();
        //        $(".Glycosylation").hide();
        //        filterOptions.residue = false;
        //    }
        //    if ($("#variant").prop("checked")) {
        //        $(".Variant").show();
        //        filterOptions.variant = true;
        //    }
        //    else {
        //        $(".Variant").hide();
        //        filterOptions.variant = false;
        //    }
        //    if ($("#region").prop("checked")) {
        //        $(".Interactingregion").show();
        //        filterOptions.region = true;
        //    }
        //    else {
        //        $(".Interactingregion").hide();
        //        filterOptions.region = false;
        //    }
        //}
        //function mappingIsoformByExons(mapping) {
        //    var minForEach = [];
        //    var max = 0;
        //    for (iso in mapping) {
        //        minForEach.push(0);
        //        console.log(mapping[iso].mapping.length);
        //        if (mapping[iso].mapping.length > max) max = mapping[iso].mapping.length;
        //    }
        //    console.log("max length" + max);
        //    for (var i=0;i<max;i++) {
        //        var min=-1;
        //        for (iso in mapping) {
        //            if ()
        //        }
        //    }
        //
        //    2:1,2,3
        //    4:1,2,3
        //    6:1,2,3
        //    9:1,3
        //    12:2
        //    14:1,2,3
        //
        //    1-9:1,2,3
        //    9-12:2
        //    12-14
        //
        //    2 = = = = = 4|6 = = = = 9 =12,14= = = = = =17,19= = =28 =33 = = = =34 = = = 37
        //    a = = = = = a|a = = = = a = a a = = = = = = a = a = = = a = a = = = = a = = = a
        //    =======|======  ===========     ==========
        //    =======|===================   ========
        //    =======|======  =========       ======
        //    var a = [[2,4],[6,9],[14,19],[33,37]]
        //    var b = [[2,4],[6,12],[14,19],[28,34]]
        //    var c = [[2,4],[6,9],[14,17],[33,34]]
        //    // for (iso in mapping) {
        //    //     for (var i=0;i<mapping[iso].mapping.length;i++) {
        //    //         for (iso in mapping) {
        //    //             for (var i=0;i<mapping[iso].mapping.length;i++) {
        //    //     }
        //    // }
        //
        //}

        $(function () {
            var startTime = new Date().getTime();
            Promise.all([nx.getProteinSequence(entry), nx.getProPeptide(entry), nx.getMatureProtein(entry), nx.getSignalPeptide(entry), nx.getPeroxisomeTransitPeptide(entry),
                nx.getMitochondrialTransitPeptide(entry), nx.getDisulfideBond(entry),nx.getAntibody(entry), nx.getInitMeth(entry), nx.getModifResidue(entry), nx.getCrossLink(entry),
                nx.getGlycoSite(entry), nx.getLipidationSite(entry), nx.getSelenocysteine(entry), nx.getPeptide(entry), nx.getSrmPeptide(entry),nx.getIsoformMapping(entry)]).then(function (oneData) {

/*                var featuresName = ["Sequence",         "Propeptide",             "Mature protein",          "Signal peptide",           "Disulfide bonds",
                    "Antibody",         "Initiator meth",       "Modified residue",         "Cross-link",           "Glycosylation",        "Peptide",
                    "Srm peptide"];
*/


                var metaData = [
                    {name: "Sequence"},
                    {name: "Propeptide",className: "pro",color: "#B3B3B3",type: "rect",filter:"Processing"},                     {name: "Mature protein",className: "mat",color: "#B3B3C2",type: "rect",filter:"Processing"},
                    {name: "Signal peptide",className: "sign",color: "#B3B3E1",type: "rect",filter:"Processing"},                {name: "Transit peptide",className: "pero",color: "#B3B3F0",type: "rect",filter:"Processing"},
                    {name: "Transit peptide",className: "mito",color: "#B3B3F0",type: "rect",filter:"Processing"},               {name: "Disulfide bond",className: "dsB",color: "#B3B3E1",type: "path",filter:"Modified Residue"},
                    {name: "Antibody",className: "anti",color: "#B3C2F0",type: "rect",filter:"none"},                            {name: "Initiator meth",className: "initMeth",color: "#B3B3D1",type: "unique",filter:"Processing"},
                    {name: "Modified residue",className: "modifRes",color: "#B3C2B3",type: "unique",filter:"Modified Residue"},  {name: "Cross-link",className: "crossLink",color: "#B3C2C2",type: "unique",filter:"Modified Residue"},
                    {name: "Glycosylation",className: "glycoSite",color: "#B3C2D1",type: "unique",filter:"Modified Residue"},    {name: "Lipidation",className: "lipidation",color: "#A3B5DB",type: "unique",filter:"Modified Residue"},
                    {name: "Non standart AA",className: "seleno",color: "#859DE7",type: "unique",filter:"Modified Residue"},      {name: "Peptide",className: "pep",color: "#B3E1D1",type: "multipleRect",filter:"Peptide"},
                    {name: "Srm Peptide",className: "srmPep",color: "#B3E1F0",type: "multipleRect",filter:"none"}
                ];

                var tv = new TripleViewer(entry);
                tv.init(oneData,metaData);

            }).catch(function (err) {
                // catch any error that happened so far
                console.log("Argh, broken: " + err.message);
                console.log("Error at line : " + err.stack);
            });
        });
    }));
</script>
</html>