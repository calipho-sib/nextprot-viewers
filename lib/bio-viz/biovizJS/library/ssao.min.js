// ssao.js / dsmu.me/license
// http://dsmu.me/sponza/sponza.htm

/*
 * Ambient occlusion
 *
 */
							
var SSAO_Params={"enable SSAO":!0,"show RT":0,"enable profiler":!0};

function initGUI(d){
		var g=new dat.GUI;
		g.add(SSAO_Params,"enable SSAO").onChange (function(c){
			d.change("enable SSAO",c);
			visualisationScreen.scene3D.renderScene()
		});
		g.add(SSAO_Params,"show RT",{frameBuffer:0,SSAO:1}).onChange(function(c){
			d.change("show RT",c);
			visualisationScreen.scene3D.renderScene();
		}).listen()
};

function SSAOConfig(d,g){
	var c=[]
	var isEnabled=!0;
	this.enableSSAO=function(bool){
		isEnabled=bool
	};
	this.isEnableSSAO=function(){
		return isEnabled
	};
	this.switchFrameBuffer=function(a){
		"0"===a?g.ssao_uniforms.onlyAO.value=!1:"1"===a?g.ssao_uniforms.onlyAO.value=!0:console.error("Not define swithFrameBuffer type: "+a)
	};
	this.change=function(a,b){
		c[a](b)
	};
	c["enable SSAO"]=this.enableSSAO;
	c["show RT"]=this.switchFrameBuffer;
};




THREE.SSAOShader = {
	uniforms:{
		tDiffuse:{type:"t",value:null},
		tDepth:{type:"t",value:null},
		size:{type:"v2",value:new THREE.Vector2(512,512)},
		cameraNear:{type:"f",value:1},
		cameraFar:{type:"f",value:100},
		onlyAO:{type:"i",value:0},
		aoClamp:{type:"f",value:0.9},
		lumInfluence:{type:"f",value:0.5}
	},
	vertexShader:"varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
	fragmentShader:"uniform float cameraNear;\
	uniform float cameraFar;\
	uniform bool onlyAO;\
	uniform vec2 size;\
	uniform float aoClamp;\
	uniform float lumInfluence;\
	uniform sampler2D tDiffuse;\
	uniform sampler2D tDepth;\
	varying vec2 vUv;\n#define DL 2.399963229728653\n#define EULER 2.718281828459045\nfloat width = size.x;\
	float height = size.y;\
	float cameraFarPlusNear = cameraFar + cameraNear;\
	float cameraFarMinusNear = cameraFar - cameraNear;\
	float cameraCoef = 2.0 * cameraNear;\
	const int samples = 8;\
	const float radius = 3.0;\
	const bool useNoise = false;\
	const float noiseAmount = 0.0003;\
	const float diffArea = 0.4;\
	const float gDisplace = 0.4;\
	float unpackDepth( const in vec4 rgba_depth ) {\
		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\
	float depth = dot( rgba_depth, bit_shift );\
	return depth;\
}\
	vec2 rand( const vec2 coord ) {\
		vec2 noise;\
	if ( useNoise ) {\
		float nx = dot ( coord, vec2( 12.9898, 78.233 ) );\
	float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\
	noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\
} else {\
		float ff = fract( 1.0 - coord.s * ( width / 2.0 ) );\
	float gg = fract( coord.t * ( height / 2.0 ) );\
	noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\
}\
	return ( noise * 2.0  - 1.0 ) * noiseAmount;\
}\
	float readDepth( const in vec2 coord ) {\
		return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );\
}\
	float compareDepths( const in float depth1, const in float depth2, inout int far ) {\
		float garea = 2.0;\
	float diff = ( depth1 - depth2 ) * 100.0;\
	if ( diff < gDisplace ) {\
		garea = diffArea;\
} else {\
		far = 1;\
}\
	float dd = diff - gDisplace;\
	float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );\
	return gauss;\
}\
	float calcAO( float depth, float dw, float dh ) {\
		float dd = radius - depth * radius;\
	vec2 vv = vec2( dw, dh );\
	vec2 coord1 = vUv + dd * vv;\
	vec2 coord2 = vUv - dd * vv;\
	float temp1 = 0.0;\
	float temp2 = 0.0;\
	int far = 0;\
	temp1 = compareDepths( depth, readDepth( coord1 ), far );\
	if ( far > 0 ) {\
		temp2 = compareDepths( readDepth( coord2 ), depth, far );\
	temp1 += ( 1.0 - temp1 ) * temp2;\
}\
	return temp1;\
}\
	void main() {\
		vec2 noise = rand( vUv );\
	float depth = readDepth( vUv );\
	float tt = clamp( depth, aoClamp, 1.0 );\
	float w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );\
	float h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );\
	float ao = 0.0;\
	float dz = 1.0 / float( samples );\
	float z = 1.0 - dz / 2.0;\
	float l = 0.0;\
	for ( int i = 0; i <= samples; i ++ ) {\
		float r = sqrt( 1.0 - z );\
	float pw = cos( l ) * r;\
	float ph = sin( l ) * r;\
	ao += calcAO( depth, pw * w, ph * h );\
	z = z - dz;\
	l = l + DL;\
}\
	ao /= float( samples );\
	ao = 1.0 - ao;\
	vec3 color = texture2D( tDiffuse, vUv ).rgb;\
	vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );\
	float lum = dot( color.rgb, lumcoeff );\
	vec3 luminance = vec3( lum );\
	vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\
	if ( onlyAO ) {\
		final = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\
}\
	gl_FragColor = vec4( final, 1.0 );\n}"
};


// var Detector={
// 	canvas:!!window.CanvasRenderingContext2D,
// 	webgl:function(){
// 		try{
// 			var d=document.createElement("canvas");
// 			return!!window.WebGLRenderingContext&&(d.getContext("webgl")||d.getContext("experimental-webgl"))
// 		} catch(g) {
// 			return!1
// 		}
// 	}(),workers:!!window.Worker,fileapi:window.File&&window.FileReader&&window.FileList&&window.Blob,
// 	getWebGLErrorMessage:function(){
// 		var d=document.createElement("div");d.id="webgl-error-message";d.style.fontFamily="monospace";d.style.fontSize="13px";d.style.fontWeight="normal";
// 		d.style.textAlign="center";d.style.background="#fff";d.style.color="#000";d.style.padding="1.5em";d.style.width="400px";d.style.margin="5em auto 0";this.webgl||(d.innerHTML=window.WebGLRenderingContext?'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br />\nFind out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.':'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">WebGL</a>.<br/>\nFind out how to get it <a href="http://get.webgl.org/" style="color:#000">here</a>.');
// 		return d
// 	},
// 	addGetWebGLMessage:function(d){
// 		var g,c;d=d||{};
// 		g=void 0!==d.parent?d.parent:document.body;
// 		d=void 0!==d.id?d.id:"oldie";
// 		c=Detector.getWebGLErrorMessage();c.id=d;
// 		g.appendChild(c)
// 	}
// };

// THREE.BinaryLoader=function(d){THREE.Loader.call(this,d)};
// THREE.BinaryLoader.prototype=Object.create(THREE.Loader.prototype);
// THREE.BinaryLoader.prototype.load=function(d,g,c,a){c=c||this.extractUrlBase(d);a=a||this.extractUrlBase(d);var b=this.showProgress?THREE.Loader.prototype.updateProgress:void 0;this.onLoadStart();this.loadAjaxJSON(this,d,g,c,a,b)};
// THREE.BinaryLoader.prototype.loadAjaxJSON=function(d,g,c,a,b,p){
// 	var h=new XMLHttpRequest;a=a&&"string"===typeof a?a:this.extractUrlBase(g);b=b&&"string"===typeof b?b:this.extractUrlBase(g);
// 	h.onreadystatechange=function(){
// 		if(4==h.readyState)
// 			if(200==h.status||0==h.status){var q=JSON.parse(h.responseText);d.loadAjaxBuffers(q,c,b,a,p)}
// 			else console.error("THREE.BinaryLoader: Couldn't load ["+g+"] ["+h.status+"]")
// 	};
// h.open("GET",g,!0);h.send(null)
// };


// // THREE.BinaryLoader.prototype.loadAjaxBuffers=function(d,g,c,a,b){var p=this,h=new XMLHttpRequest,q=c+d.buffers;h.addEventListener("load",function(b){b=h.response;void 0===b&&(b=(new Uint8Array(h.responseBody)).buffer);if(0==b.byteLength){b=new ArrayBuffer(h.responseText.length);for(var c=new Uint8Array(b),q=0,y=h.responseText.length;q<y;q++)c[q]=h.responseText.charCodeAt(q)&255}p.createBinModel(b,g,a,d.materials)},!1);void 0!==b&&h.addEventListener("progress",function(d){d.lengthComputable&&b(d,p.statusDomElement)},
// // !1);h.addEventListener("error",function(d){console.error("THREE.BinaryLoader: Couldn't load ["+q+"] ["+h.status+"]")},!1);h.open("GET",q,!0);h.responseType="arraybuffer";h.overrideMimeType&&h.overrideMimeType("text/plain; charset=x-user-defined");h.send(null)};
// THREE.BinaryLoader.prototype.createBinModel=function(d,g,c,a){
// 	var b=function(a) {
// 		function b(n){
// 			return n%4?4-n%4:0
// 		}
// 		function c(n,e) {
// 			return(new Uint8Array(n,e,1))[0]
// 		}
// 		function g(n,e) {
// 			return(new Uint32Array(n,e,1))[0]
// 		}
// 		function B(n,e) {
// 			var k,a,b,c,f,g,h,l=new Uint32Array(d,e,3*n);for(k=0;k<n;k++)a=l[3*k],b=l[3*k+1],c=l[3*k+2],f=m[2*a],g=m[2*a+1],a=m[2*b],h=m[2*b+1],b=m[2*c],c=m[2*c+1],u.faceVertexUvs[0].push([new THREE.Vector2(f,g),new THREE.Vector2(a,h),new THREE.Vector2(b,c)])
// 		}
// 		function C(n,e) {
// 			var k,a,b,c,f,g,h,l,s,p=new Uint32Array(d,e,4*n);for(k=0;k<n;k++)a=p[4*k],b=p[4*k+1],c=p[4*k+2],f=p[4*k+3],g=m[2*a],h=m[2*a+1],a=m[2*b],l=m[2*b+1],b=m[2*c],s=m[2*c+1],c=m[2*f],f=m[2*f+1],u.faceVertexUvs[0].push([new THREE.Vector2(g,h),new THREE.Vector2(a,l),new THREE.Vector2(c,f)]),u.faceVertexUvs[0].push([new THREE.Vector2(a,l),new THREE.Vector2(b,s),new THREE.Vector2(c,f)])
// 		}
// 		function y(n,e,k) {
// 			var a,b,c,f;
// 			e=new Uint32Array(d,e,3*n);
// 			var g=new Uint16Array(d,k,n);
// 			for(k=0;k<n;k++)
// 				a=e[3*k],b=e[3*k+1],c=e[3*k+2],f=g[k],u.faces.push(new THREE.Face3(a,b,c,null,null,f))
// 		}
// 		function D(n,e,k) {
// 			var a,b,c,f,g;
// 			e=new Uint32Array(d,e,4*n);
// 			var h=new Uint16Array(d,k,n);
// 			for(k=0;k<n;k++)
// 				a=e[4*k],b=e[4*k+1],c=e[4*k+2],f=e[4*k+3],g=h[k],u.faces.push(new THREE.Face3(a,b,f,null,null,g)),u.faces.push(new THREE.Face3(b,c,f,null,null,g))
// 		}
// 		function E(n,e,a,b) {
// 			var c,f,g,h,p,m,s;
// 			e=new Uint32Array(d,e,3*n);
// 			a=new Uint32Array(d,a,3*n);
// 			var t=new Uint16Array(d,b,n);
// 			for(b=0;b<n;b++) {
// 				c=e[3*b];
// 				f=e[3*b+1];
// 				g=e[3*b+2];
// 				p=a[3*b];
// 				m=a[3*b+1];
// 				s=a[3*b+2];
// 				h=t[b];
// 				var q=l[3*m],r=l[3*m+1];
// 				m=l[3*m+2];
// 				var w=l[3*s],v=l[3*s+1];
// 				s=l[3*s+2];
// 				u.faces.push(new THREE.Face3(c,f,g,[new THREE.Vector3(l[3*p],l[3*p+1],l[3*p+2]),new THREE.Vector3(q,r,m),new THREE.Vector3(w,v,s)],null,h))
// 			}
// 		}
// 		function F(a,e,b,c) {
// 			var f,g,h,p,m,t,s,q,r;
// 			e=new Uint32Array(d,e,4*a);
// 			b=new Uint32Array(d,b,4*a);
// 			var w=new Uint16Array(d,c,a);
// 			for(c=0;c<a;c++) {
// 				f=e[4*c];
// 				g=e[4*c+1];
// 				h=e[4*c+2];
// 				p=e[4*c+3];
// 				t=b[4*c];
// 				s=b[4*c+1];
// 				q=b[4*c+2];
// 				r=b[4*c+3];
// 				m=w[c];
// 				var v=l[3*s],x=l[3*s+1];
// 				s=l[3*s+2];
// 				var z=l[3*q],A=l[3*q+1];
// 				q=l[3*q+2];
// 				var y=l[3*r],B=l[3*r+1];
// 				r=l[3*r+2];
// 				u.faces.push(new THREE.Face3(f,g,p,[new THREE.Vector3(l[3*t],l[3*t+1],l[3*t+2]),new THREE.Vector3(v,x,s),new THREE.Vector3(y,B,r)],null,m));
// 				u.faces.push(new THREE.Face3(g,h,p,[new THREE.Vector3(v,x,s),new THREE.Vector3(z,A,q),new THREE.Vector3(y,B,r)],null,m))
// 			}
// 		}
// 		var u=this;
// 		a=0;
// 		var f,l=[],m=[],w,v,x,z,A,t,r;THREE.Geometry.call(this);
// 		f=function(a,e){
// 			for(var b=new Uint8Array(a,e,12),d="",f=0;12>f;f++)
// 				d+=String.fromCharCode(b[e+f]);
// 			return{ 
// 				signature:d,header_bytes:c(a,e+12),vertex_coordinate_bytes:c(a,e+13),normal_coordinate_bytes:c(a,e+14),uv_coordinate_bytes:c(a,e+15),vertex_index_bytes:c(a,e+16),normal_index_bytes:c(a,e+17),uv_index_bytes:c(a,e+18),material_index_bytes:c(a,e+19),nvertices:g(a,e+20),nnormals:g(a,e+20+4),nuvs:g(a,e+20+8),ntri_flat:g(a,e+20+12),ntri_smooth:g(a,e+20+16),ntri_flat_uv:g(a,e+20+20),ntri_smooth_uv:g(a,e+20+24),nquad_flat:g(a,e+20+28),nquad_smooth:g(a,e+20+32),nquad_flat_uv:g(a,e+20+36),nquad_smooth_uv:g(a,e+20+40)
// 			}
// 		}(d,a);
// 		a+=f.header_bytes;
// 		t=3*f.vertex_index_bytes+f.material_index_bytes;
// 		r=4*f.vertex_index_bytes+f.material_index_bytes;
// 		w=f.ntri_flat*t;
// 		v=f.ntri_smooth*(t+3*f.normal_index_bytes);
// 		x=f.ntri_flat_uv*(t+3*f.uv_index_bytes);
// 		z=f.ntri_smooth_uv*(t+3*f.normal_index_bytes+3*f.uv_index_bytes);
// 		A=f.nquad_flat*r;
// 		t=f.nquad_smooth*(r+4*f.normal_index_bytes);
// 		r=f.nquad_flat_uv*(r+4*f.uv_index_bytes);
// 		a+=function(a) {
// 			var e=f.nvertices;
// 			a=new Float32Array(d,a,3*e);
// 			var b,c,g,h;
// 			for(b=0;b<e;b++)
// 				c=a[3*b],g=a[3*b+1],h=a[3*b+2],u.vertices.push(new THREE.Vector3(c,g,h));
// 			return 3*e*Float32Array.BYTES_PER_ELEMENT
// 		}(a);
// 		a+=function(a){
// 			var e=f.nnormals;
// 			if(e){
// 				a=new Int8Array(d,a,3*e);
// 				var b,c,g,h;
// 				for(b=0;b<e;b++)
// 					c=a[3*b],g=a[3*b+1],h=a[3*b+2],l.push(c/127,g/127,h/127)
// 			}
// 			return 3*e*Int8Array.BYTES_PER_ELEMENT
// 		}(a);
// 		a+=b(3*f.nnormals);
// 		a += function(a){
// 			var e=f.nuvs;
// 			if(e){
// 				a=new Float32Array(d,a,2*e);
// 				var b,c,g;
// 				for(b=0;b<e;b++)
// 					c=a[2*b],g=a[2*b+1],m.push(c,g)
// 			}
// 			return 2*e*Float32Array.BYTES_PER_ELEMENT
// 		}(a);
// 		w=a+w+b(2*f.ntri_flat);
// 		v=w+v+b(2*f.ntri_smooth);
// 		x=v+x+b(2*f.ntri_flat_uv);
// 		z=x+z+b(2*f.ntri_smooth_uv);
// 		A=z+A+b(2*f.nquad_flat);
// 		t=A+t+b(2*f.nquad_smooth);
// 		r=t+r+b(2*f.nquad_flat_uv);
// 		(function(a){ 
// 			var b=f.ntri_flat_uv;
// 			if(b) {
// 				var c=a+b*Uint32Array.BYTES_PER_ELEMENT*3;
// 				y(b,a,c+b*Uint32Array.BYTES_PER_ELEMENT*3);
// 				B(b,c)
// 			}
// 		})(v);
// 		(function(a){
// 			var b=f.ntri_smooth_uv;
// 			if(b) {
// 				var c=a+b*Uint32Array.BYTES_PER_ELEMENT*3,d=c+b*Uint32Array.BYTES_PER_ELEMENT*3;
// 				E(b,a,c,d+b*Uint32Array.BYTES_PER_ELEMENT*3);
// 				B(b,d)
// 			}
// 		})(x);
// 		(function(a){
// 			var b=f.nquad_flat_uv;
// 			if(b){
// 				var c=a+b*Uint32Array.BYTES_PER_ELEMENT*4;
// 				D(b,a,c+b*Uint32Array.BYTES_PER_ELEMENT*4);
// 				C(b,c)
// 			}
// 		})(t);
// 		(function(a) {
// 			var b=f.nquad_smooth_uv;
// 			if(b){var c=a+b*Uint32Array.BYTES_PER_ELEMENT*4,d=c+b*Uint32Array.BYTES_PER_ELEMENT*4;
// 				F(b,a,c,d+b*Uint32Array.BYTES_PER_ELEMENT*4);
// 				C(b,d)
// 			}
// 		})(r);
// 		(function(a) {
// 			var b=f.ntri_flat;
// 			b&&y(b,a,a+b*Uint32Array.BYTES_PER_ELEMENT*3)
// 		})(a);
// 		(function(a) {
// 			var b=f.ntri_smooth;
// 			if(b){
// 				var c=a+b*Uint32Array.BYTES_PER_ELEMENT*3;
// 				E(b,a,c,c+b*Uint32Array.BYTES_PER_ELEMENT*3)
// 			}
// 		})(w);
// 		(function(a) {
// 			var b=f.nquad_flat;
// 			b&&D(b,a,a+b*Uint32Array.BYTES_PER_ELEMENT*4)
// 		})(z);
// 		(function(a) {
// 			var b=f.nquad_smooth;
// 			if(b){
// 				var c=a+b*Uint32Array.BYTES_PER_ELEMENT*4;
// 				F(b,a,c,c+b*Uint32Array.BYTES_PER_ELEMENT*4)
// 			}
// 		})(A);
// 		this.computeFaceNormals()
// 	};
// 	b.prototype=Object.create(THREE.Geometry.prototype);
// 	b=new b(c);
// 	c=this.initMaterials(a,c);
// 	this.needsTangents(c)&&b.computeTangents();
// 	g(b,c)
// };
			


	// THREE.FirstPersonControls=function(d,g){
	// 	function c(a,b){
	// 		return function(){b.apply(a,arguments)}
	// 	}
	// 	this.object=d;
	// 	this.target=new THREE.Vector3(0,0,0);
	// 	this.domElement=void 0!==g?g:document;
	// 	this.movementSpeed=1;
	// 	this.lookSpeed=0.005;
	// 	this.lookVertical=!0;
	// 	this.autoForward=!1;
	// 	this.activeLook=!0;
	// 	this.heightSpeed=!1;
	// 	this.heightCoef=1;
	// 	this.heightMin=0;
	// 	this.heightMax=1;
	// 	this.constrainVertical=!1;
	// 	this.verticalMin=0;
	// 	this.verticalMax=Math.PI;
	// 	this.theta=this.phi=this.lon=this.lat=this.mouseY=this.mouseX=this.autoSpeedFactor=0;
	// 	this.mouseDragOn=this.freeze=this.moveRight=this.moveLeft=this.moveBackward=this.moveForward=!1;
	// 	this.viewHalfY=this.viewHalfX=0;this.domElement!==document&&this.domElement.setAttribute("tabindex",-1);
	// 	this.handleResize=function(){
	// 		this.domElement===document?(this.viewHalfX=window.innerWidth/2,this.viewHalfY=window.innerHeight/2):(this.viewHalfX=this.domElement.offsetWidth/2,this.viewHalfY=this.domElement.offsetHeight/2)
	// 	};

	// 	this.onMouseDown=function(a){this.domElement!==document&&this.domElement.focus();
	// 		a.preventDefault();a.stopPropagation();if(this.activeLook)switch(a.button){case 0:this.moveForward=!0;break;case 2:this.moveBackward=!0}this.mouseDragOn=!0};

	// 	this.onMouseUp=function(a){a.preventDefault();a.stopPropagation();if(this.activeLook)switch(a.button){case 0:this.moveForward=!1;break;case 2:this.moveBackward=!1}this.mouseDragOn=!1};
	// 	this.onMouseMove=function(a){this.domElement===document?(this.mouseX=a.pageX-this.viewHalfX,this.mouseY=a.pageY-this.viewHalfY):(this.mouseX=a.pageX-this.domElement.offsetLeft-
	// 	this.viewHalfX,this.mouseY=a.pageY-this.domElement.offsetTop-this.viewHalfY)};


	// 	this.onKeyDown=function(a){switch(a.keyCode){case 38:case 87:this.moveForward=!0;break;case 37:case 65:this.moveLeft=!0;break;case 40:case 83:this.moveBackward=!0;break;case 39:case 68:this.moveRight=!0;break;case 82:this.moveUp=!0;break;case 70:this.moveDown=!0;break;case 81:this.freeze=!this.freeze}};
	// 		this.onKeyUp=function(a){
	// 		switch(a.keyCode) {
	// 			case 38:case 87:this.moveForward=!1;
	// 			break;
	// 			case 37:case 65:this.moveLeft=!1;break;
	// 			case 40:case 83:this.moveBackward=!1;break;
	// 			case 39:case 68:this.moveRight=!1;break;
	// 			case 82:this.moveUp=!1;break;case 70:this.moveDown=!1
	// 		}
	// 	};
	// 	this.update=function(a){
	// 		if(!this.freeze){
	// 			if(this.heightSpeed){
	// 				var b=THREE.Math.clamp(this.object.position.y,this.heightMin,this.heightMax)-this.heightMin;this.autoSpeedFactor=a*b*this.heightCoef
	// 			}
	// 			else this.autoSpeedFactor=0;b=a*this.movementSpeed;
	// 			(this.moveForward||this.autoForward&&!this.moveBackward)&&this.object.translateZ(-(b+this.autoSpeedFactor));
	// 			this.moveBackward&&this.object.translateZ(b);
	// 			this.moveLeft&&this.object.translateX(-b);this.moveRight&&this.object.translateX(b);
	// 			this.moveUp&&this.object.translateY(b);
	// 			this.moveDown&&this.object.translateY(-b);
	// 			a*=this.lookSpeed;
	// 			this.activeLook||(a=0);
	// 			b=1;
	// 			this.constrainVertical&&(b=Math.PI/(this.verticalMax-this.verticalMin));
	// 			this.lon+=this.mouseX*a;
	// 			this.lookVertical&&(this.lat-=this.mouseY*a*b);
	// 			this.lat=Math.max(-85,Math.min(85,this.lat));
	// 			this.phi=THREE.Math.degToRad(90-this.lat);
	// 			this.theta=THREE.Math.degToRad(this.lon);
	// 			this.constrainVertical&&(this.phi=THREE.Math.mapLinear(this.phi,0,Math.PI,this.verticalMin,this.verticalMax));
	// 			a=this.target;
	// 			b=this.object.position;
	// 			a.x=b.x+100*Math.sin(this.phi)*Math.cos(this.theta);
	// 			a.y=b.y+100*Math.cos(this.phi);
	// 			a.z=b.z+100*Math.sin(this.phi)*Math.sin(this.theta);
	// 			this.object.lookAt(a);
	// 		}
	// 	};
	// 	this.domElement.addEventListener("contextmenu",function(a){a.preventDefault()},!1);
	// 	this.domElement.addEventListener("mousemove",c(this,this.onMouseMove),!1);
	// 	this.domElement.addEventListener("mousedown",c(this,this.onMouseDown),!1);
	// 	this.domElement.addEventListener("mouseup",c(this,this.onMouseUp),!1);
	// 	window.addEventListener("keydown",c(this,this.onKeyDown),!1);
	// 	window.addEventListener("keyup",c(this,this.onKeyUp),!1);
	// 	this.handleResize()
	// };