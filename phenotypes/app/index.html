<!DOCTYPE html>
<html>

<head>
    <title>neXtProt phenotypes</title>
    <meta charset="UTF-8">
    <script type="text/javascript" src="https://use.fontawesome.com/aeec643a8b.js"></script>
    <link href='https://fonts.googleapis.com/css?family=Lato:100,300,400,700,900' rel='stylesheet' type='text/css'>
    <script type="text/javascript" src="handlebars.min.js"></script>
    <script type="text/javascript" src="jquery.min.js"></script>
    <script type="text/javascript" src="nextprot-core.js"></script>
    <script type="text/javascript" src="heatmap-table.js"></script>
    <script type="text/javascript" src="bootstrap.min.js"></script>
    <script type="text/javascript" src="iframeResizer.contentWindow.min.js"></script>
    <link rel="stylesheet" href="heatmap-table.css" crossorigin="anonymous">
    <!--    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">-->
    <link rel="stylesheet" href="bootstrap.min.css">
    <link rel="stylesheet" href="style.css" />
</head>

<style>
   
</style>

<div id="nx-overview"></div>

<script id="detailTemplate" type="text/x-handlebars-template">
    <div class="evidence-block">
        <div class="evidence-line">
            <div class="evidenceArrow">⤵</div>
            <span class="evidence-index">Evidence {{@index}}</span>
            <span class="evidence-code">{{evidenceCodeName}}</span> 
            <span class="evidence-source">{{resourceDb}}</span>
        </div>
        <div class="evidence-link"><a href="https://search.nextprot.org">{{resourceAccession}}</a></div>
    </div>
</script>

<script id="form-template" type="text/x-handlebars-template">

    <div>
        <h3 class="filter-title second-title">PHENOTYPES</h3> {{#each this}}
        <div id="panel{{@index}}" class="panel-group">
            <div class="panel panel-default">
                <div class="panel-heading">
                    <a class="collapse-title collapsed" data-toggle="collapse" href="#collapse{{@index}}">
                        <span class="chevron"><i class="fa"></i></span>
                        <h4 class="panel-title"> {{{badge}}} <span>{{@key}}</span> <span class="badge phenoCount">{{count}}</span>
                        </h4>
                    </a>
                    <a class="select-all pull-right" referTo="#collapse{{@index}}">All <i class="fa fa-check" aria-hidden="true"></i></a>
                </div>
                <div id="collapse{{@index}}" class="panel-collapse collapse">
                    <ul class="list-group subtypes">
                        {{#each data}}
                        <li class="list-group-item"><a class="active"><i class="fa fa-check" aria-hidden="true"></i><span class="phenAnnot">{{@key}}</span> <span class="badge phenoCount">{{this}}</span></a></li>
                        {{/each}}
                    </ul>
                </div>
            </div>
        </div>
        {{/each}}
    </div>

</script>

<body id="phenotypeViewer">

    <h1><span style="font-weight:300;">phenotypes</span></h1>
    <div class="row" style="margin:0px;">
        <div class="col-lg-10 col-lg-offset-1 col-md-offset-1 col-md-10">
            <!--
        <div class="row">
            <img src="ftvariant.png" style="width:600px; margin: 0 auto; margin: 20px">
        </div>
-->
            <div class="row">
                <div class="col-md-12">
                    <div class="filters"></div>
                </div>
            </div>
<!--            <hr>-->
            <div class="row">
                <div class="col-md-12">
                    <h3 class="variant-title second-title">VARIANTS</h3>
                </div>
                <div class="col-md-12">
                    <div class="legends pull-right">
                        <p><i class="heatmap-circle " style="background-color: #2D882D"></i> No impact</p>
                        <p><i class="heatmap-circle " style="background-color: #AA3939"></i> Impact</p>
                        <p><i class="heatmap-circle " style="background-color: #226666"></i> Gain</p>
                        <p><i class="heatmap-circle " style="background-color: #D49A6A"></i> Increase</p>
                        <p><i class="heatmap-circle " style="background-color: #F7D492"></i> Decrease</p>
<!--
                        <h3>
                            CAPTION
                        </h3>
-->
                    </div>
                    <div class="legends legends-count pull-left">
<!--
                        <h3>
                            DISPLAYED
                        </h3>
-->
                        <p><span id="count-pheno"></span> annotations</p>
                    </div>
                </div>
            </div>


            <div class="row">
                <div id="heatmap-table0" style="width:100%;margin: 20px auto 50px auto; height:auto;"></div>
            </div>
<!--
            <div class="row">
                <div id="heatmap-table2" style="width:100%;margin: 20px auto 50px auto; height:auto;"></div>
            </div>
            <div class="row">
                <div id="heatmap-table3" style="width:100%;margin: 20px auto 50px auto; height:auto;"></div>
            </div>
            <div class="row">
                <div id="heatmap-table" style="width:100%;margin: 20px auto 50px auto; height:auto;"></div>
            </div>
-->
        </div>
    </div>

    <script defer>
        //NX DATA PARSING UTILS


        function hashingNormalAnnotations(annotations) {
            var hashNormalAnnotation = {};
            annotations.forEach(function (a) {
                hashNormalAnnotation[a.annotationHash] = a;
            })
            return hashNormalAnnotation;
        }

        function getMinPos(subjects) {
            var min = 100000;
            subjects.forEach(function (s) {
                var pos = s.locationCanonicalBegin;
                if (min > pos) min = pos;
            })
            return min;
        }

        function sortPhenotypesByPosition(a, b) {
            var minPosA = getMinPos(a.subjectComponents);
            var minPosB = getMinPos(b.subjectComponents);
            return minPosA - minPosB;
        }

        function getListAnnotRef(phenotypes){
            var list = [];
            phenotypes.forEach(function(p){
                p.annotations.forEach(function(a){
                    list.push(a.bioObject.annotationHash);
                })
            });
            return list;
        }
        function getAllAnnotationTypes(annots, phenotypes) {
//            console.log("phenotypes");
//            console.log(phenotypes);
            var listAnnotRef = getListAnnotRef(phenotypes);
//            console.log("listAnnotRef");
//            console.log(listAnnotRef);
//            console.log("annots");
//            console.log(annots);
            var listingPhenotype = {};
            //            console.log(annots);
            listAnnotRef.forEach(function(a){
                if (annots.hasOwnProperty(a)){
                    if (!listingPhenotype.hasOwnProperty(annots[a].apicategory)) {
                        listingPhenotype[annots[a].apicategory] = {
                            badge: annotTypeTemplate[annots[a].apicategory],
                            count: 0,
                            data: {}
                        };
                    }
                    if(annots[a].category === 'BinaryInteraction'){
                        var pheno = annots[a].bioObject.accession;
//                        console.log(annots[a]);
                    }else {
                        var pheno = annots[a].cvTermName;
                    }
                    if (listingPhenotype[annots[a].apicategory].data.hasOwnProperty(pheno)) {
                        listingPhenotype[annots[a].apicategory].data[pheno] += 1;
                        listingPhenotype[annots[a].apicategory].count += 1;
                    } else {
                        listingPhenotype[annots[a].apicategory].data[pheno] = 1;
                        listingPhenotype[annots[a].apicategory].count += 1;
                    }
                }
            });
            console.log("listingPhenotype");
            console.log(listingPhenotype);
            return listingPhenotype;
        }


        function getVariantInfos(variants) {
            var variantInfos = {
                fullName: "",
                evidences: []
            };
            var subjectName = "";
            var varList = variants.map(function (v, i, array) {
                //Only get the first position, dont check if there is others isoforms
                var pos = v.locationCanonicalBegin;
                var original = v.variant.original;
                var variant = v.variant.variant;
                //                var evidences = v.evidences.map(function(e){
                //                    return {
                //                        evidenceCodeName : e.evidenceCodeName,
                //                        resourceDb : e.resourceDb,
                //                        resourceAccession : e.resourceAccession
                //                    }
                //                })
                return {
                    pos: pos,
                    original: original,
                    variant: variant
                        //                    evidences: evidences
                };
            });
            varList.sort(function (a, b) {
                return a.pos - b.pos
            });

            varList.forEach(function (v, i, array) {
                var name = "<span class='varDisplay'><span class='varPos'>" + v.pos + "</span><span class='varSeq'>" + v.original + " → " + v.variant + "</span></span>";
                if (i < array.length - 1) name += " ";
                variantInfos.fullName += name;
                //                variantInfos.evidences = variantInfos.evidences.concat(v.evidences);
            })
            return variantInfos;
        }

        function getAnnotationById(annotations, id) {
            if (annotations.hasOwnProperty(id)) {
                return {
                    category: annotations[id].apicategory,
                    cvTermName: annotations[id].apicategory === "BINARY_INTERACTION" ? annotations[id].bioObject.accession : annotations[id].cvTermName
                }
            } else console.warn("couldn't find normal annotation " + id);
        }

        function generateFakeEvidence() {
            var evidences = [];
            var count = Math.floor((Math.random() * 3));
            for (var i = 0; i < count; i++) {
                var ev = {
                    evidenceCodeName: "This is a fake evidence",
                    resourceDb: "neXtProt",
                    resourceAccession: "123456789"
                }
                evidences.push(ev);
            }
            return evidences;
        }

        function getImpact(impacts, annots, template, filters) {
            var listPhenotypes = [];
            var fakeEvidences = []
            impacts.forEach(function (i) {
                var category = i.category;
                var cvTermName = i.cvTermName.toLowerCase();
                var annotationAffected = getAnnotationById(annots, i.bioObject.annotationHash);
                if (!filters || filters.indexOf(annotationAffected.cvTermName) !== -1) {
                    var customTemplate = jQuery.extend(true, {}, template);
                    customTemplate.rowLabel = "<strong>" + cvTermToSentence[cvTermName] + "</strong> " + annotationAffected.cvTermName + " " + annotTypeTemplate[annotationAffected.category];
                    customTemplate.values[0] = cvTermName !== "no-impact" ? "" : "no-impact";
                    customTemplate.values[1] = cvTermName !== "no-impact" ? cvTermName : "";
                    customTemplate.detailData = generateFakeEvidence();
                    listPhenotypes.push(customTemplate);
                }
            })
            return listPhenotypes;
        }

        function propagateImpact(children) {
            var values = ["", ""];
            for (var c in children) {
                if (children[c].values[1] !== "") {
                    values[1] = "impact";
                    return values;
                }
            }
            values[0] = "no-impact";
            return values;
        }


        function parseNxDataForTreeTable(phenotypes, annotations, template, filters) {
            console.log('phenotypes');
            console.log(phenotypes);
            var treeTable = {
                data: []
            };

            phenotypes.forEach(function (p) {
                var varTemplate = jQuery.extend(true, {}, template);
                varTemplate.children = getImpact(p.annotations, annotations, template, filters);
                if (varTemplate.children.length) {
                    var varInfos = getVariantInfos(p.subjectComponents);
                    varTemplate.rowLabel = varInfos.fullName;
                    varTemplate.detailData = varInfos.evidences;
                    varTemplate.values = propagateImpact(varTemplate.children);
                    treeTable.data.push(varTemplate);
                }
            })

            return treeTable;
        }

        function addSelectAll() {
            $(".select-all").click(function () {
                $("i", this).toggleClass("fa-circle-thin fa-check");
                var matchingList = $(this).attr("referTo");
                if ($("i", this).hasClass("fa-check")) {
                    $(matchingList + " a").each(function () {
                        if (!$(this).hasClass("active")) {
                            $(this).addClass("active");
                            $("i", this).toggleClass("fa-circle-thin fa-check");
                        }

                    })
                } else {
                    $(matchingList + " a").each(function () {
                        if ($(this).hasClass("active")) {
                            $(this).removeClass("active");
                            $("i", this).toggleClass("fa-circle-thin fa-check");
                        }

                    })
                }
            })
        }

        function fillFilters(data) {
            var source = $("#form-template").html();
            var template = Handlebars.compile(source);
            var html = template(data);
            $(".filters").html(html);
            $(".subtypes a").click(function () {
                $(this).toggleClass("active");
                $("i", this).toggleClass("fa-circle-thin fa-check");
            })
            addSelectAll();
        }

        function getFilters() {
            var filters = [];
            $(".filters .subtypes a").each(function () {
                //                console.log("one");
                if ($(this).hasClass("active")) {
                    var uniqueFilter = $(this).find(".phenAnnot").text();
                    filters.push(uniqueFilter);
                }
            });
            return filters;

        }
        
        function autoCheckAll(elem){
            var panel = $(elem).closest(".panel-group");
            var all = panel.find(".select-all i");
            var activeFilters = panel.find(".subtypes a.active");
            if (!activeFilters.length && all.hasClass("fa-check")) {
                all.toggleClass("fa-circle-thin fa-check");
            }
            else if (activeFilters.length === panel.find(".subtypes a").length){
                if (all.hasClass("fa-circle-thin")) {
                    all.toggleClass("fa-circle-thin fa-check");
                }
            }
        }

        function activateFilters(data, annots) {
            $(".filters a:not(.collapse-title)").click(function () {
                var filters = getFilters();
                autoCheckAll($(this)) ;
                resetTreeViewer(data, annots, filters);
            })
        }
        
        function countPhenotypes(data){
            var count = 0;
            data.forEach(function(d){
                count+= d.children.length;
            })
            $("#count-pheno").text(count);
        }

        var nx = new Nextprot.Client("neXtProt proteomics view", "Calipho-Team");
        if (nx.getEnvironment() !== "bed") {
        //    nx.setApiBaseUrl("http://bed-api.nextprot.org");
            nx.setApiBaseUrl("http://localhost:8080/nextprot-api-web");

        }


        var entry = nx.getEntryName();
        console.log(entry);

        var heatmapTableOptions0 = {
            valuesColorMapping: [
                {
                    value: 'impact',
                    color: '#AA3939'
                },
                {
                    value: 'increase',
                    color: '#D49A6A'
                },
                {
                    value: 'decrease',
                    color: '#F7D492'
                },
                {
                    value: 'no-impact',
                    color: '#2D882D'
                },
                {
                    value: 'gain',
                    color: '#226666'
                }
            ],
            columnWidth: "120px",
            detailTemplate: "detailTemplate"
        }

        var cvTermToSentence = {
            "impact": "has impact on",
            "no-impact": "has no impact on",
            "decrease": "decreases",
            "increase": "increases",
            "gain": "gains"
        }

        var annotTypeTemplate = {
            "GO_MOLECULAR_FUNCTION": "<span class='badge gmf'>GO-MF</span>",
            "GO_CELLULAR_COMPONENT": "<span class='badge gcc'>GO-CC</span>",
            "GO_BIOLOGICAL_PROCESS": "<span class='badge gbp'>GO-BP</span>",
            "BINARY_INTERACTION": "<span class='badge bi'>BI</span>"
        }


        var template = {
            "rowLabel": "",
            "linkLabel": "",
            "linkURL": "",
            "values": ["", ""],
            "children": []
        };

        function resetTreeViewer(data, annots, filters) {
            $("#heatmap-table0").html("");
            // parse Data to fit the template of treeData - WITH FILTERS
            var treeDataFiltered = parseNxDataForTreeTable(data, annots, template, filters);
            
            // add count box - WITH FILTERS ON
            countPhenotypes(treeDataFiltered.data);
            
            var heatMapTable0 = new HeatMapTable({
                header: ['no-impact', 'impact'],
                tableID: "heatmap-table0",
                options: heatmapTableOptions0
            });

            heatMapTable0.loadJSONData(treeDataFiltered);
            heatMapTable0.show();
            //            addIconToButton();
        }

        //        function addIconToButton(){
        //            
        //            var wait = setInterval(function(){ searchElem() }, 50);
        //            
        //            function searchElem(){
        //                var elem = $("#heatmap-table0 .heatmap-reset-btn");
        //                if ($(elem).length>0) {
        //                    $(".heatmap-filterByRowName-search").prepend('<span class="fa fa-search treeBtn" aria-hidden="true"></span>');
        //                    $(".heatmap-reset-btn").prepend('<span class="fa fa-refresh treeBtn" aria-hidden="true"></span>');
        //                    $(".heatmap-collapseAll-btn").prepend('<span class="fa fa-compress treeBtn" aria-hidden="true"></span>');
        //                    $(".heatmap-expandAll-btn").prepend('<span class="fa fa-expand treeBtn" aria-hidden="true"></span>');
        //                    console.log("clearInterval");
        //                    clearInterval(wait);
        //                }
        //            }
        //        }

        nx.getFullAnnotationsByCategory(entry, "modified-entry-annotation").then(function (data) {
            console.log("data");
            console.log(data);

            // Transform annotations into hashMap to ease the access by id
            var normalAnnotations = hashingNormalAnnotations(data.isoformAnnotations[entry + "-1"]);

            // Sort phenotypes by smallest position
            var phenotypes = data.modifiedEntryAnnotations.sort(sortPhenotypesByPosition);

            // Get all phenotypes by type in order to add them into the filter block
            var listingPhenotypes = getAllAnnotationTypes(normalAnnotations, phenotypes);
            fillFilters(listingPhenotypes);

            // parse Data to fit the template of treeData
            var treeData = parseNxDataForTreeTable(phenotypes, normalAnnotations, template);

            // add count box
            countPhenotypes(treeData.data);

            activateFilters(phenotypes, normalAnnotations);

            console.log("treeData");
            console.log(treeData);

            var heatMapTable0 = new HeatMapTable({
                header: ['no-impact', 'impact'],
                tableID: "heatmap-table0",
                options: heatmapTableOptions0
            });

            heatMapTable0.loadJSONData(treeData);
            heatMapTable0.show();

        })


    </script>

</body>

</html>
